<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="format-detection" content="telephone=no" />
        <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />

        <title>Pixel</title>

        <script type="text/javascript" src="cordova.js"></script>

        <style type="text/css">
            html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background-color:white; }
            div#fullpage { width:100%; height:100%; margin:0; padding:0; border:0px solid red; text-align:center; vertical-align:middle; }
            button { font-size: 18px; }
        </style>

        <script type="text/javascript" src="js/hammer.min-1.0.5.js"></script>

        <script type="text/javascript" src="js/jquery-1.9.1.min.js"></script>
        <script type="text/javascript" src="js/modernizr.js"></script>

        <script type="text/javascript" src="js/pixel.js"></script>
        <script type="text/javascript" src="js/looper.js"></script>

        <script type="text/javascript" src="js/processing.js"></script>
        <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">

        <link href='http://fonts.googleapis.com/css?family=Didact+Gothic' rel='stylesheet' type='text/css'>

        <link type="text/css" rel="stylesheet" href="css/style.css" />

        <head profile="http://www.w3.org/2005/10/profile">
        <link rel="icon" type="image/png" href="/favicon.png">
    </head>

    <body onload="onLoad()">
    <script>
    var httpd = null;
    function onLoad() {
    	document.addEventListener ("deviceready", onDeviceReady, false);
    }

    function startUdpServer () {

        datagram = window.dgram;

        //var datagram = cordova.require("in.girish.datagram.datagram");
        var broadcastSocket = datagram.createSocket("multicast-udp4", 4445);
        broadcastSocket.bind(function(data) {
            console.log(" data ===> " + data);
        });

        broadcastSocket.on("message", function(data, info) {
            alert(data);
            alert(JSON.stringify(info));
            // broadcastSocket.send("Hi!", info.address, 4445, function() {

            // });

            // TODO: Handle UDP packets from Pixels...
        });
    }

    function onDeviceReady () {
        httpd = ( cordova && cordova.plugins && cordova.plugins.CorHttpd ) ? cordova.plugins.CorHttpd : null;
        // alert (httpd);

        startServer("htdocs");

        startUdpServer ();

        setInterval(function () {
            udpBroadcast ();
        }, 5000);

        // datagram = window.dgram;

        // //var datagram = cordova.require("in.girish.datagram.datagram");
        // var broadcastSocket = datagram.createSocket("multicast-udp4", 4445);
        // // broadcastSocket.bind(function(data) {
        // //     console.log(" data ===> " + data);
        // // });

        // // broadcastSocket.on("message", function(data, info) {
        // //     alert(data);
        // //     alert(JSON.stringify(info));
        // //     // broadcastSocket.send("Hi!", info.address, 4445, function() {

        // //     // });
        // // });
        // broadcastSocket.send("Hello", "255.255.255.255", 4445, function() {

        // });

        // var datagram = cordova.require("in.girish.datagram.datagram");
        // alert (datagram);
        // alert (JSON.stringify(window.dgram));
        // alert (window.dgram.createSocket);
        // var dgram = cordova.require("cordova/plugin/dgram");
        // alert (dgram);
            //udpBroadcast
    }

    function updateStatus () {
    	document.getElementById('location').innerHTML = "document.location.href: " + document.location.href;
    	if (httpd) {
    		httpd.getURL (function (url) {
    			if(url.length > 0) {
    				document.getElementById('url').innerHTML = "server is up: <a href='" + url + "' target='_blank'>" + url + "</a>";
    			} else {
    				document.getElementById('url').innerHTML = "server is down.";
    			}

                document.getElementById('looper').innerHTML = "<a href='" + url + "/looper.html' target='_blank'>Looper</a>";
    		});
    		httpd.getLocalPath (function (path){
    			document.getElementById ('localpath').innerHTML = "<br/>localPath: " + path;
        	});
    	} else {
    		alert ('CorHttpd plugin not available/ready.');
    	}
    }

    function startServer (wwwroot) {
    	if (httpd) {
    	    httpd.getURL (function (url) {
    	    	if (url.length > 0) {
    	    		document.getElementById ('url').innerHTML = "server is up: <a href='" + url + "' target='_blank'>" + url + "</a>";

	    	    } else {
    	    	    httpd.startServer ({
    	    	    	'www_root' : wwwroot,
    	    	    	'port' : 8080
    	    	    }, function (url) {
                        g_deviceUrl = url;
                        // updateStatus ();
    	    	    }, function (error) {
    	    	    	document.getElementById ('url').innerHTML = 'failed to start server: ' + error;
    	    	    });
    	    	}
    	    	
    	    }, function () {});
    	} else {
    		alert('CorHttpd plugin not available/ready.');
    	}
    }

    function stopServer () {
    	if (httpd) {
    	    httpd.stopServer (function (){
    	    	//document.getElementById ('url').innerHTML = 'server is stopped.';
                //updateStatus ();
    	    }, function (error){
    	    	document.getElementById ('url').innerHTML = 'failed to stop server' + error;
    	    });
    	} else {
    		alert ('CorHttpd plugin not available/ready.');
    	}
    }

    // MG: Gets the list of Pixel modules are available
    function getModulesHTTP () {

        var http = new XMLHttpRequest ();
        var url = g_deviceUrl.concat ("/modules");
        var params = "";
        url = url.concat ('?', params);
        
        http.open ("GET", url, true);

        // Send the proper header information along with the request
        http.setRequestHeader ("Content-Type", "application/x-www-form-urlencoded");
        // http.setRequestHeader ('Access-Control-Allow-Origin', '*');
        http.setRequestHeader ('X-PINGOTHER', 'pingpong');
        
        http.onreadystatechange = function () { // Call a function when the state changes.
            if (http.readyState == 4 && http.status == 200) {
                // console.log("Behavior got successfully.");
                alert (http.responseText);

                // TODO: Update the behavior's state based on the response behavior data.

                // if (callback !== undefined) {
                //     callback(); // The callback function
                // }
            } else if(http.readyState == 4 && http.status == 404) {
                alert ("fail");
            }
        }
        http.send (params);
    }

    function getModules () {
        if (httpd) {
            httpd.getModules (function (response) {
                if (response.length > 0) {

                    var moduleListString = response.substring (1, response.length - 1); // Remove the bounding '[' and ']' characters.

                    var moduleArray = moduleListString.split (/\s*,\s*/); // split by comma

                    for (var i = 0; i < moduleArray.length; i++) {

                        if (moduleArray[i].length > 0) { // if the module string is not empty

                            if (moduleList.indexOf (moduleArray[i]) > -1) { // if module is already in the list...
                                
                            } else { // if the module is not already in the list...
                                // alert ("Adding: " + moduleArray[i]);
                                moduleList.push (moduleArray[i]); // add the module to the list
                                looper.addDevice({ address: moduleArray[i] });
                                looper.showDeviceByIndex(moduleList.length - 1); // ...show it!
                            }

                        }
                    }

                    // var moduleArray = moduleListString.split (", "); // split by comma

                    // if (moduleListString.length > 0) {
                    //     var rawModuleStrings = moduleListString.split (","); // Extract "module-ip=module-ip" pairs

                    //     var rawModuleCount = rawModuleStrings.length;
                    //     for (var i = 0; i < rawModuleCount; i++) {

                    //         var rawSingleModuleString = rawModuleStrings[i];

                    //         var singleModule = rawSingleModuleString.split ("="); // Extract "module-ip=module-ip" pairs
                    //         var moduleIP = singleModule[0];

                    //         // Check if the module is already in the list of modules. If not, add it. If so, update it.
                    //         if (moduleList.indexOf (moduleIP) > -1) { // Check if the module is in the list...

                    //         } else { // Check if the module is NOT in the list...
                    //             // alert ("Adding: " + moduleIP);
                    //             moduleList.push (moduleIP);

                    //             // Add to Looper
                    //             looper.addDevice({ address: moduleIP });
                    //             // if (moduleList.length == 1) { // if this is the first module...
                    //                 looper.showDeviceByIndex(moduleList.length - 1); // ...show it!
                    //             // }
                    //         }

                    //         // if (moduleObjects[moduleIP] === undefined) { // Check if the module IS NOT already in the list
                    //         //     moduleObjects[moduleIP] = moduleIP;
                    //         // } else { // ...if the module is already in the list (e.g., then update it!)
                    //         //     moduleObjects[moduleIP] = moduleIP;
                    //         // }

                    //         // alert (moduleObjects);
                    //     }


                    //     // Echo the modules in the list
                    //     // alert (moduleList);
                    //     if (moduleList.length > 0) {
                    //         // for (var i = 0; i < moduleList.length; i++) {
                    //         //     alert (moduleList[i]);
                    //         // }
                    //     }
                    // }

                } else {
                    alert ("getModules fail");
                }
            });
            // httpd.getLocalPath (function (path){
            //     document.getElementById ('localpath').innerHTML = "<br/>localPath: " + path;
            // });
        } else {
            alert ('CorHttpd plugin not available/ready.');
        }
    }

    // function udpBroadcast () {

    //     // Start UDP transmitter
    //     // Simple usage, initialize once, setting the IP address and port of the intended receiver
    //     // udptransmit.initialize("192.168.1.133", 4445);
    //     var addressWithPort = g_deviceUrl.substring (7);
    //     var address = addressWithPort.substring (0, g_deviceUrl.lastIndexOf (":"));
    //     var broadcastAddress = address.substring(0, address.lastIndexOf (".") + 1) + "255";
    //     // alert (address);
    //     udptransmit.initialize(broadcastAddress, 4445);

    //     // Then send messages over and over
    //     udptransmit.sendMessage("Pixel: " + addressWithPort);
    //     // udptransmit.sendMessage("PIXEL UDP");
    //     // udptransmit.sendMessage("PIXEL UDP");
    //     // udptransmit.sendMessage("PIXEL UDP");
    //     // udptransmit.sendMessage("PIXEL UDP");

    // }

    function udpBroadcast () {

        var addressWithPort = g_deviceUrl.substring (7);
        var address = addressWithPort.substring (0, g_deviceUrl.lastIndexOf (":"));
        var broadcastAddress = address.substring(0, address.lastIndexOf (".") + 1) + "255";
        
        datagram = window.dgram;

        //var datagram = cordova.require("in.girish.datagram.datagram");
        var broadcastSocket = datagram.createSocket("multicast-udp4", 4445);
        // broadcastSocket.bind(function(data) {
        //     console.log(" data ===> " + data);
        // });

        // broadcastSocket.on("message", function(data, info) {
        //     alert(data);
        //     alert(JSON.stringify(info));
        //     // broadcastSocket.send("Hi!", info.address, 4445, function() {

        //     // });
        // });
        broadcastSocket.send("@all notice presence", "255.255.255.255", 4445, function() {

        });

    }

    // Documentation: http://plugins.cordova.io/#/package/org.apache.cordova.device-motion
    function getAccelerometerData () {
        function onSuccess (acceleration) {
            document.getElementById ('acceleration').innerHTML = 
                  'Acceleration X: ' + acceleration.x + '<br />' +
                  'Acceleration Y: ' + acceleration.y + '<br />' +
                  'Acceleration Z: ' + acceleration.z + '<br />' +
                  'Timestamp: '      + acceleration.timestamp;
        };

        function onError() {
            alert('onError!');
        };

        navigator.accelerometer.getCurrentAcceleration(onSuccess, onError);
    }

    </script>

    <!-- NOTE: Hammer.js works without jQuery! -->
    <!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script> -->
    <!-- <script type="text/javascript" src="js/jquery-1.9.1.min.js"></script> -->
    <!-- <script type="text/javascript" src="js/modernizr.js"></script> -->

    <!--<div id="debug">Log</div>-->

    <!-- Set up carousel -->
    <div id="carousel">
        <ul id="panes">

            <li class="pane1">
                <canvas id="looperCanvas" style="width: 100%; height: 100%;"></canvas>
            </li>

        </ul>
    </div>

    <!-- Include Hammer.js (for gesture recognition) -->
    <script type="text/javascript" src="js/jquery.hammer-1.0.5.js"></script>
    <script>

    /*
    var debug_el = $("#debug");
    function debug(text) {
        debug_el.text(text);
    }
    */

    /**
     * requestAnimationFrame and cancel polyfill
     */
    (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
            window.cancelAnimationFrame =
                    window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
        }

        if (!window.requestAnimationFrame)
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                        timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };

        if (!window.cancelAnimationFrame)
            window.cancelAnimationFrame = function(id) {
                clearTimeout (id);
            };
    }());

    </script>

    <!-- Include Processing.js -->
    <script type="application/processing" data-processing-target="looperCanvas">
    /*
    @pjs
    crisp=true;
    font="Comfortaa-Regular.ttf";
    */
    PFont primaryFont;

    void setup() {
        size (screenWidth, screenHeight);

        primaryFont = loadFont ("Comfortaa-Regular.ttf");
    }

    void draw () {
        background (#ffffff);
        primaryFont = createFont ("Comfortaa-Regular.ttf", 32);
        textFont (primaryFont, 40);
        textAlign (CENTER);
        fill (65, 65, 65);
        text ("pixeI", screenWidth / 2, screenHeight / 2 + 20);
    }
    </script>

    <script src="js/pixel.js"></script>
    <script src="js/looper.js"></script>
    <script>
    looper = new Looper ();
    looper.addDevice({ address: "192.168.1.13" });
    looper.addDevice({ address: "192.168.1.14" });
    looper.showDeviceByIndex(0);
    // erase();


    // create interface: behavior interface
    // create interface: slider: dot and line
    // create interface

    // function attachSlider (options) {
    function Slider (options) {

        var defaults = {
            parent: null,
            xOrigin: 0,
            yOrigin: 0,
            xTarget: 100,
            yTarget: 0,
            x: 0,
            y: 0,
            properties: [], // The properties of the interface that determine the ways of interacting with it
        };
        var options = options || {};
        var options = $.extend({}, defaults, options);

        options.structure = this; // Set the structure to this slider

        // Validate and copy the options to this class, to be used for creating an interface
        this.parent = options.parent; // i.e., the Behavior


        //looper.getCurrentDevice().attachInterface({
        var newInterface = this.parent.interface.attachInterface ({

            structure: null, // looper.getCurrentDevice(),

            properties: options.properties,

            // TODO: HACK! Fix this so the Processing instance is found automatically through the interface hierarchy!
            processing: looper.getCurrentDevice().processing, // this.looperInstance.processing,

            // The position of an interface is relative to its parent (if any), otherwise, relative to the window (or screen).
            xOrigin: options.xOrigin, // The origin of the interface's coordinate system along the x axis. This is relative to the parent's position along the x axis.
            yOrigin: options.yOrigin, // The origin of the interface's coordinate system along the y axis. This is relative to the parent's position along the y axis.
            xTarget: options.xTarget, // i.e., The desired or final position of the interface along the x axis. This is where the interface will eventually be (e.g., after it is animated into position).
            yTarget: options.yTarget, // i.e., The desired or final position of the interface along the y axis. This is where the interface will eventually be (e.g., after it is animated into position).
            x: options.x, // options.x, // was ev.gesture.center.x, // i.e., The current actual position of the interface along the x axis. This is updated in the drawing loop and will ultimately be equal to the target x position.
            y: options.y, // options.y, // was ev.gesture.center.y, // i.e., The current actual position of the interface along the y axis. This is updated in the drawing loop and will ultimately be equal to the target y position.

            // minX: 100,
            // maxX: 300,

            // This function determines whether the specified (x,y) point falls within the bounds of this interface.
            touches: function (x, y) {
                // alert (x, y, this.x, this.y);
                var radius = 50;
                // DEBUG: console.log (x, y, this.x, this.y);
                if (((this.xOrigin + this.x) - radius < x && (this.xOrigin + this.x) + radius > x) && ((this.yOrigin + this.y) - radius < y && (this.yOrigin + this.y) + radius > y)) {
                // if ((x - radius < this.processing.behaviorPalette.x + this.x && this.processing.behaviorPalette.x + this.x < x + radius)
                //     && (y - radius < this.processing.behaviorPalette.y + this.y && this.processing.behaviorPalette.y + this.y < y + radius)) {

                    return true;
                }

                return false;
            },

            // Updates the state of the interface before drawing
            update: function () {

            // Set constants
                this.min = 100;
                this.max = 300;

                // if (looper.getCurrentDevice ().touch.touching === true) {
                if (this.down) { // If touched

                    // Hide the cursor while sliding
                    // $('html').css('cursor', 'none');

                    // console.log ("DOWN");

                    // currentMouseX = (this.processing.screenWidth * (this.processing.deviceCount + 1) + this.processing.mouseX) - (this.processing.screenWidth / 2) - (this.xOrigin);
                    // console.log("currentMouseX: " + currentMouseX);
                    // console.log("screenMouseX: " + this.processing.screenMouseX);
                    // console.log("processing.zoomedCanvasMouseX: " + this.processing.zoomedCanvasMouseX);
                    currentMouseX = this.processing.zoomedCanvasMouseX - (this.xOrigin);
                    // currentMouseX = (this.processing.screenWidth * (this.processing.deviceCount + 1) + this.processing.mouseX) - (this.processing.screenWidth / 2) - (this.xOrigin);
                    // DEBUG: console.log (currentMouseX);
                    if (currentMouseX < this.min) {
                        currentMouseX = this.min;
                    } else if (currentMouseX > this.max) {
                        currentMouseX = this.max;
                    }

                    // console.log (currentMouseX);

                    // this.setPosition (currentMouseX, this.y);
                    // this.setPosition (currentMouseX, this.yOrigin + this.y);
                    this.setPosition (currentMouseX, this.y);
                } else {

                    // Show the mouse cursor
                    // $('html').css('cursor', 'auto');

                    // Hide the cursor while sliding
                    // $('html').css('cursor', 'auto');
                }

                this.updatePosition ();

            },

            draw: function () {

                this.update ();

                this.processing.pushMatrix();

                // Draw background of widget
                this.processing.line (this.xOrigin + this.min, this.yOrigin + this.y, this.xOrigin + this.max, this.yOrigin + this.y);

                // Draw the behavior
                this.processing.fill (66, 214, 146);
                // this.processing.ellipse (this.xOrigin + this.x, this.yOrigin + this.y, 30, 30);
                this.processing.ellipse (this.xOrigin + this.x, this.yOrigin + this.y, 30, 30);

                this.processing.popMatrix();


                // TODO: Invoke "callback" or "signal" for current state
                var range = this.max - this.min;
                var current = this.x - this.min;

                var value = current / range;
                // console.log (value + "%");

                var scaledMinimum = this.properties.minimum;
                var scaledMaximum = this.properties.maximum; // 1024;
                var scaledValue = value * (scaledMaximum - scaledMinimum) + scaledMinimum;
                this.value = scaledValue;
                this.structure.value = scaledValue;
                // alert (this.structure.value); // this.interface.<slider>.<behavior node>
                // alert (this.behavior.properties.length);
                // this.parent.values[this.name] = this.value;
                // console.log (scaledValue + " (scaled)");

                // TODO: Send musical note to Pixel via Looper

            },

            events: {
                tap: function() {
                    console.log ("tap Behavior");
                },

                touch: function() {
                    console.log ("touch Behavior");
                    console.log (this);
                    console.log (this.interface);

                    disableEventCreate = true;

                    this.interface.down = true;

                    // Hide the mouse cursor
                    // $('html').css('cursor', 'none');
                },

                hold: function () {
                    console.log("hold Behavior");
                },

                release: function () {
                    console.log("release Behavior");

                    this.interface.down = false;

                    disableEventCreate = false;

                    this.interface.properties.interface = this.interface;
                    this.interface.properties.callback ();

                    // Show the mouse cursor
                    // $('html').css('cursor', 'auto');
                }
            }
        });

        newInterface.properties = options.properties;

        newInterface.structure = this;

        return newInterface;

    }

    </script>

    <!-- 
    <div id="fullpage">
        <strong>HTTP Server</strong>

        <p>
            <button onclick="startServer('htdocs');">Start Httpd at www/htdocs</button>
            <button onclick="startServer('/');">Start Httpd at /</button>
            <button onclick="stopServer();">Stop Httpd</button>
            <button onclick="updateStatus();">Check Status</button>
            <button onclick="getModules();">Get Modules</button></p>
            <button onclick="getModulesHTTP();">Get Modules (HTTP)</button>
            <button onclick="hello();">Hello</button>
            <button onclick="goodbye();">Goodbye</button>
        </p>

        <div id='location'></div>
        <div id='url'></div>
        <div id='localpath'></div>

        <h2><div id="looper">Looper</div></h2>

        <strong>UDP Client</strong>

        <p><button onclick="udpBroadcast();">UDP Broadcast</button></p>

        <strong>Accelerometer</strong>

        <p><button onclick="getAccelerometerData();">Accelerometer</button></p>

        <div id="acceleration"></div>
    </div> 
    -->
    
    </body>
</html>
