<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="format-detection" content="telephone=no" />
        <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />

        <title>Pixel</title>

        <script type="text/javascript" src="cordova.js"></script>

        <style type="text/css">
            html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background-color:white; }
            div#fullpage { width:100%; height:100%; margin:0; padding:0; border:0px solid red; text-align:center; vertical-align:middle; }
            button { font-size: 18px; }
        </style>

        <script type="text/javascript" src="js/hammer.min-1.0.5.js"></script>

        <script type="text/javascript" src="js/jquery-1.9.1.min.js"></script>
        <script type="text/javascript" src="js/modernizr.js"></script>

        <script type="text/javascript" src="js/pixel.js"></script>
        <script type="text/javascript" src="js/looper.js"></script>

        <script type="text/javascript" src="js/processing.js"></script>
        <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">

        <link href='http://fonts.googleapis.com/css?family=Didact+Gothic' rel='stylesheet' type='text/css'>

        <link type="text/css" rel="stylesheet" href="css/style.css" />

        <head profile="http://www.w3.org/2005/10/profile">
        <link rel="icon" type="image/png" href="/favicon.png">
    </head>

    <body onload="onLoad()">
    <script>
    function onLoad() {
    	document.addEventListener ("deviceready", onDeviceReady, false);
    }

    function Start_UDP_Server () {

        datagram = window.dgram; // get a reference to the PhoneGap Dgram library

        var broadcastSocket = datagram.createSocket ("multicast-udp4", 4445);
        broadcastSocket.bind (function (data) {
            console.log(" data ===> " + data);
        });

        broadcastSocket.on ("message", function (data, info) {
            if (address !== undefined && info.address !== address) {
                // alert (data);
                // alert (JSON.stringify (info));

                if (moduleList.indexOf (info.address) > -1) { // if module is already in the list...
                    
                } else { // if the module is not already in the list...
                    // alert ("Adding: " + moduleArray[i]);
                    moduleList.push (info.address); // add the module to the list
                    looper.addDevice ({ address: info.address });
                    looper.showDeviceByIndex (moduleList.length - 1); // ...show it!
                }
            }
        });
    }

    function Start_UDP_Broadcast () {
        setInterval (function () {
            Broadcast_UDP_Client (); // Expose (); // Start_UDP_Broadcaster (); // send "@all present" or "@all be"
        }, 5000);
    }

    function onDeviceReady () {

        // Get the IP address of the device
        networkinterface.getIPAddress(function (ip) { 
            address = ip;
        });

        // Start UDP server to watch for other devices and broadcast presence to other devices.
        Start_UDP_Server (); // Watch_For_Peers (); // Start_UDP_Server (); // watch for Pixels announcing "@all notify"
        Start_UDP_Broadcast ();
    }

    // function updateStatus () {
    // 	document.getElementById('location').innerHTML = "document.location.href: " + document.location.href;
    // 	if (httpd) {
    // 		httpd.getURL (function (url) {
    // 			if(url.length > 0) {
    // 				document.getElementById('url').innerHTML = "server is up: <a href='" + url + "' target='_blank'>" + url + "</a>";
    // 			} else {
    // 				document.getElementById('url').innerHTML = "server is down.";
    // 			}

    //             document.getElementById('looper').innerHTML = "<a href='" + url + "/looper.html' target='_blank'>Looper</a>";
    // 		});
    // 		httpd.getLocalPath (function (path){
    // 			document.getElementById ('localpath').innerHTML = "<br/>localPath: " + path;
    //     	});
    // 	} else {
    // 		alert ('CorHttpd plugin not available/ready.');
    // 	}
    // }

    // function startServer (wwwroot) {
    // 	if (httpd) {
    // 	    httpd.getURL (function (url) {
    // 	    	if (url.length > 0) {
    // 	    		document.getElementById ('url').innerHTML = "server is up: <a href='" + url + "' target='_blank'>" + url + "</a>";

	   //  	    } else {
    // 	    	    httpd.startServer ({
    // 	    	    	'www_root' : wwwroot,
    // 	    	    	'port' : 8080
    // 	    	    }, function (url) {
    //                     g_deviceUrl = url;
    //                     // updateStatus ();
    // 	    	    }, function (error) {
    // 	    	    	document.getElementById ('url').innerHTML = 'failed to start server: ' + error;
    // 	    	    });
    // 	    	}
    	    	
    // 	    }, function () {});
    // 	} else {
    // 		alert('CorHttpd plugin not available/ready.');
    // 	}
    // }

    // function stopServer () {
    // 	if (httpd) {
    // 	    httpd.stopServer (function (){
    // 	    	//document.getElementById ('url').innerHTML = 'server is stopped.';
    //             //updateStatus ();
    // 	    }, function (error){
    // 	    	document.getElementById ('url').innerHTML = 'failed to stop server' + error;
    // 	    });
    // 	} else {
    // 		alert ('CorHttpd plugin not available/ready.');
    // 	}
    // }

    // MG: Gets the list of Pixel modules are available
    // function getModulesHTTP () {

    //     var http = new XMLHttpRequest ();
    //     var url = g_deviceUrl.concat ("/modules");
    //     var params = "";
    //     url = url.concat ('?', params);
        
    //     http.open ("GET", url, true);

    //     // Send the proper header information along with the request
    //     http.setRequestHeader ("Content-Type", "application/x-www-form-urlencoded");
    //     // http.setRequestHeader ('Access-Control-Allow-Origin', '*');
    //     http.setRequestHeader ('X-PINGOTHER', 'pingpong');
        
    //     http.onreadystatechange = function () { // Call a function when the state changes.
    //         if (http.readyState == 4 && http.status == 200) {
    //             // console.log("Behavior got successfully.");
    //             alert (http.responseText);

    //             // TODO: Update the behavior's state based on the response behavior data.

    //             // if (callback !== undefined) {
    //             //     callback(); // The callback function
    //             // }
    //         } else if(http.readyState == 4 && http.status == 404) {
    //             alert ("fail");
    //         }
    //     }
    //     http.send (params);
    // }

    // function getModules () {
    //     if (httpd) {
    //         httpd.getModules (function (response) {
    //             if (response.length > 0) {

    //                 var moduleListString = response.substring (1, response.length - 1); // Remove the bounding '[' and ']' characters.

    //                 var moduleArray = moduleListString.split (/\s*,\s*/); // split by comma

    //                 for (var i = 0; i < moduleArray.length; i++) {

    //                     if (moduleArray[i].length > 0) { // if the module string is not empty

    //                         if (moduleList.indexOf (moduleArray[i]) > -1) { // if module is already in the list...
                                
    //                         } else { // if the module is not already in the list...
    //                             // alert ("Adding: " + moduleArray[i]);
    //                             moduleList.push (moduleArray[i]); // add the module to the list
    //                             looper.addDevice({ address: moduleArray[i] });
    //                             looper.showDeviceByIndex(moduleList.length - 1); // ...show it!
    //                         }

    //                     }
    //                 }

    //                 // var moduleArray = moduleListString.split (", "); // split by comma

    //                 // if (moduleListString.length > 0) {
    //                 //     var rawModuleStrings = moduleListString.split (","); // Extract "module-ip=module-ip" pairs

    //                 //     var rawModuleCount = rawModuleStrings.length;
    //                 //     for (var i = 0; i < rawModuleCount; i++) {

    //                 //         var rawSingleModuleString = rawModuleStrings[i];

    //                 //         var singleModule = rawSingleModuleString.split ("="); // Extract "module-ip=module-ip" pairs
    //                 //         var moduleIP = singleModule[0];

    //                 //         // Check if the module is already in the list of modules. If not, add it. If so, update it.
    //                 //         if (moduleList.indexOf (moduleIP) > -1) { // Check if the module is in the list...

    //                 //         } else { // Check if the module is NOT in the list...
    //                 //             // alert ("Adding: " + moduleIP);
    //                 //             moduleList.push (moduleIP);

    //                 //             // Add to Looper
    //                 //             looper.addDevice({ address: moduleIP });
    //                 //             // if (moduleList.length == 1) { // if this is the first module...
    //                 //                 looper.showDeviceByIndex(moduleList.length - 1); // ...show it!
    //                 //             // }
    //                 //         }

    //                 //         // if (moduleObjects[moduleIP] === undefined) { // Check if the module IS NOT already in the list
    //                 //         //     moduleObjects[moduleIP] = moduleIP;
    //                 //         // } else { // ...if the module is already in the list (e.g., then update it!)
    //                 //         //     moduleObjects[moduleIP] = moduleIP;
    //                 //         // }

    //                 //         // alert (moduleObjects);
    //                 //     }


    //                 //     // Echo the modules in the list
    //                 //     // alert (moduleList);
    //                 //     if (moduleList.length > 0) {
    //                 //         // for (var i = 0; i < moduleList.length; i++) {
    //                 //         //     alert (moduleList[i]);
    //                 //         // }
    //                 //     }
    //                 // }

    //             } else {
    //                 alert ("getModules fail");
    //             }
    //         });
    //         // httpd.getLocalPath (function (path){
    //         //     document.getElementById ('localpath').innerHTML = "<br/>localPath: " + path;
    //         // });
    //     } else {
    //         alert ('CorHttpd plugin not available/ready.');
    //     }
    // }

    // function udpBroadcast () {

    //     // Start UDP transmitter
    //     // Simple usage, initialize once, setting the IP address and port of the intended receiver
    //     // udptransmit.initialize("192.168.1.133", 4445);
    //     var addressWithPort = g_deviceUrl.substring (7);
    //     var address = addressWithPort.substring (0, g_deviceUrl.lastIndexOf (":"));
    //     var broadcastAddress = address.substring(0, address.lastIndexOf (".") + 1) + "255";
    //     // alert (address);
    //     udptransmit.initialize(broadcastAddress, 4445);

    //     // Then send messages over and over
    //     udptransmit.sendMessage("Pixel: " + addressWithPort);
    //     // udptransmit.sendMessage("PIXEL UDP");
    //     // udptransmit.sendMessage("PIXEL UDP");
    //     // udptransmit.sendMessage("PIXEL UDP");
    //     // udptransmit.sendMessage("PIXEL UDP");

    // }

    function Broadcast_UDP_Client () { // udpBroadcast () {

        datagram = window.dgram;

        var port = 4445;
        var addressWithPort = address + ":" + port;
        var broadcastAddress = address.substring (0, address.lastIndexOf (".") + 1) + "255";

        //var datagram = cordova.require("in.girish.datagram.datagram");
        var broadcastSocket = datagram.createSocket ("multicast-udp4", port);

        //broadcastSocket.send("@all notice presence", "255.255.255.255", 4445, function() {
        //var message = "@all notice presence " + addressWithPort;
        var message = "PIXEL: " + addressWithPort;
        broadcastSocket.send (message, "255.255.255.255", port, function () {});

    }

    // Documentation: http://plugins.cordova.io/#/package/org.apache.cordova.device-motion
    function getAccelerometerData () {
        function onSuccess (acceleration) {
            document.getElementById ('acceleration').innerHTML = 
                  'Acceleration X: ' + acceleration.x + '<br />' +
                  'Acceleration Y: ' + acceleration.y + '<br />' +
                  'Acceleration Z: ' + acceleration.z + '<br />' +
                  'Timestamp: '      + acceleration.timestamp;
        };

        function onError() {
            alert('onError!');
        };

        navigator.accelerometer.getCurrentAcceleration(onSuccess, onError);
    }

    </script>

    <!-- NOTE: Hammer.js works without jQuery! -->
    <!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script> -->
    <!-- <script type="text/javascript" src="js/jquery-1.9.1.min.js"></script> -->
    <!-- <script type="text/javascript" src="js/modernizr.js"></script> -->

    <!--<div id="debug">Log</div>-->

    <!-- Set up carousel -->
    <div id="carousel">
        <ul id="panes">

            <li class="pane1">
                <canvas id="looperCanvas" style="width: 100%; height: 100%;"></canvas>
            </li>

        </ul>
    </div>

    <!-- Include Hammer.js (for gesture recognition) -->
    <script type="text/javascript" src="js/jquery.hammer-1.0.5.js"></script>
    <script>

    /*
    var debug_el = $("#debug");
    function debug(text) {
        debug_el.text(text);
    }
    */

    /**
     * requestAnimationFrame and cancel polyfill
     */
    (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
            window.cancelAnimationFrame =
                    window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
        }

        if (!window.requestAnimationFrame)
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                        timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };

        if (!window.cancelAnimationFrame)
            window.cancelAnimationFrame = function(id) {
                clearTimeout (id);
            };
    }());

    </script>

    <!-- Include Processing.js -->
    <script type="application/processing" data-processing-target="looperCanvas">
    /*
    @pjs
    crisp=true;
    font="Comfortaa-Regular.ttf";
    */
    PFont primaryFont;

    void setup() {
        P = this;

        frameRate (30);

        size (screenWidth, screenHeight);

        font = loadFont("Comfortaa-Regular.ttf");

        primaryFont = loadFont ("Comfortaa-Regular.ttf");

        looper.xOffsetOrigin = screenWidth / 2;
        looper.yOffsetOrigin = screenHeight / 2;
        looper.xOffset = 0.0;
        looper.yOffset = 0.0;
        looper.xOffsetPrevious = 0.0;
        looper.yOffsetPrevious = 0.0;
        looper.zoomFactor = 0.6;

        //
        // Initialize data structures
        //

        if (looper.geometry === undefined) { looper.geometry = {}; }
        if (looper.geometry.loop === undefined) { looper.geometry.loop = {}; } // i.e., the containing loop
        if (looper.geometry.loop.position === undefined) { looper.geometry.loop.position = {}; }
        if (looper.geometry.behavior === undefined) { looper.geometry.behavior = {}; } // i.e., the current behavior
        if (looper.geometry.behavior.position === undefined) { looper.geometry.behavior.position = {}; }
        if (looper.geometry.condition === undefined) { looper.geometry.condition = {}; } // i.e., the current behavior's condition

        if (looper.loop === undefined) { looper.loop = {}; }
        if (looper.loop.behaviors === undefined) { looper.loop.behaviors = []; }
        if (looper.behaviors === undefined) { looper.behaviors = []; }

        looper.loop.entanglingDistance = 120;

        looper.geometry.loop.position = { x: 0, y: 0 };
        looper.geometry.loop.radius = 200;
        looper.geometry.loop.emptyScaleFactor = 0.9; // if the loop is empty, scale the radius by this amount (i.e., the radius will be emptyScaleFactor * radius)
        looper.geometry.loop.startAngle = 0;
        looper.geometry.loop.startAngleOffset = 0.15;
        looper.geometry.loop.endAngle = 2 * this.PI;
        looper.geometry.loop.endAngleOffset = 0.15;
        looper.geometry.loop.arrowSegmentLength = 12;

        if (looper.loop.style === undefined) { looper.loop.style = {}; }

        looper.loop.style.strokeWeight = 2.0;
        looper.loop.style.strokeColor = { red: 200, green: 200, blue: 200 };

        if (looper.touch === undefined) { looper.touch = {}; }
        if (looper.touch.touch === undefined) { looper.touch.touch = {}; }
        if (looper.touch.current === undefined) { looper.touch.current = {}; }
        if (looper.touch.release === undefined) { looper.touch.release = {}; }

        // this.processing.canvas = canvas;
        // looper.deviceCount = deviceCount;
        // looper.looperInstance = this;

        // TODO: Rename to processScreenGesture
        // TODO: Consider renaming to senseScreenGesture or something else replacing the word "process" to something more appropriate
        looper.processGesture = function (event) {
            // DEBUG: console.log ("processGesture");

            // TODO:
            // Ensure the following exist:
            //    processing.view = {}
            //    processing.interactions

            // var touches = event.gesture.touches;
            looper.touch.current = { x: event.x, y: event.y, t: (new Date()).getTime() };

            // console.log ("Processing (mouseX, mouseY): " + P.mouseX + ", " + P.mouseY);

            // console.log (((looper.getCurrentPane() + 1) * $(window).width()) + processing.mouseX);
            // console.log (processing.mouseY);

            // { x: ev.gesture.center.pageX, y: ev.gesture.center.pageY, t: (new Date()).getTime() }
            looper.screenMouseX = event.x; // event.gesture.center.pageX; // ((looper.getCurrentPane() + 1) * processing.screenWidth) + processing.mouseX;
            looper.screenMouseY = event.y; // event.gesture.center.pageY; // processing.mouseY;
            // DEBUG: console.log ("Screen (mouseX, mouseY), calculated: " + processing.screenMouseX + ", " + processing.screenMouseY);
            // console.log ("Screen (mouseX, mouseY), calculated: " + looper.screenMouseX + ", " + looper.screenMouseY);

            looper.canvasMouseX = looper.screenMouseX - looper.xOffsetOrigin; // ((looper.getCurrentPane()) * processing.screenWidth) + processing.mouseX + (processing.xOffsetOrigin);
            looper.canvasMouseY = looper.screenMouseY - looper.yOffsetOrigin; // processing.mouseY - (processing.yOffsetOrigin);
            // DEBUG: console.log ("Canvas (mouseX, mouseY), calculated: " + processing.canvasMouseX + ", " + processing.canvasMouseY);
            // console.log ("Canvas (mouseX, mouseY), calculated: " + looper.canvasMouseX + ", " + looper.canvasMouseY);

            // console.log ("zoomFactor: " + processing.zoomFactor);
            looper.pannedCanvasMouseX = looper.canvasMouseX - looper.xOffset; // (1 + (1 - processing.zoomFactor)) * (((looper.getCurrentPane()) * processing.screenWidth) + (processing.mouseX + processing.xOffsetOrigin - processing.xOffset));
            looper.pannedCanvasMouseY = looper.canvasMouseY - looper.yOffset; // (1 + (1 - processing.zoomFactor)) *  (processing.mouseY - (processing.yOffsetOrigin) - (processing.yOffset));
            // DEBUG: console.log ("Panned canvas (mouseX, mouseY), calculated (no zooming): " + processing.pannedCanvasMouseX + ", " + processing.pannedCanvasMouseY);
            // console.log ("Panned canvas (mouseX, mouseY), calculated (no zooming): " + looper.pannedCanvasMouseX + ", " + looper.pannedCanvasMouseY);

            // Calculate canvas coordinates of panned and zoomed point
            // var inverseZoom = (1 + (1 - processing.zoomFactor));
            // console.log ("inverseZoom: " + inverseZoom);
            looper.zoomedCanvasMouseX = (looper.canvasMouseX - looper.xOffset) / looper.zoomFactor; // * processing.zoomFactor; // (1 + (1 - processing.zoomFactor)) * (((looper.getCurrentPane()) * processing.screenWidth) + (processing.mouseX + processing.xOffsetOrigin - processing.xOffset));
            looper.zoomedCanvasMouseY = (looper.canvasMouseY - looper.yOffset) / looper.zoomFactor; // * processing.zoomFactor; // (1 + (1 - processing.zoomFactor)) *  (processing.mouseY - (processing.yOffsetOrigin) - (processing.yOffset));
            // DEBUG: console.log ("Zoomed and panned canvas (mouseX, mouseY), calculated: " + processing.zoomedCanvasMouseX + ", " + processing.zoomedCanvasMouseY);
            // console.log ("Zoomed and panned canvas (mouseX, mouseY), calculated: " + looper.zoomedCanvasMouseX + ", " + looper.zoomedCanvasMouseY);

            // if (processing.draggingCanvas == true) {
            //     //touch.draggingCanvas = true;
            //     processing.draggingCanvas = false;

            //     // Save mouse touch location
            //     var currentMouseX = (((looper.getCurrentPane() + 1) * $(window).width()) + processing.mouseX);
            //     var currentMouseY = processing.mouseY;

            //     // Store previous offset
            //     processing.xOffset = currentMouseX - processing.mouse_x + processing.xOffsetPrevious;
            //     processing.yOffset = currentMouseY - processing.mouse_y + processing.yOffsetPrevious;
            // }

        }


        looper.addDevice({ address: "192.168.1.13" });

        /**
         * Returns the coordinates for the point on the loop nearest to the specified point.
         */
        looper.getNearestPositionOnEventLoop = function (x, y) {
            // x = x + processing.screenWidth;
            // DEBUG: console.log ("Get nearest to: " + x + ", " + y);

            var xPositionOfLoop = 0; // - processing.xOffset;
            var yPositionOfLoop = 0; // - processing.yOffset;
            // DEBUG: console.log ("LOOP(x,y) = " + xPositionOfLoop + ", " + yPositionOfLoop);
            var deltaX = x - xPositionOfLoop; // x difference between specified point and center of loop
            var deltaY = y - yPositionOfLoop; // y difference between specified point and center of loop
            // DEBUG: console.log ("deltaX: " + deltaX);
            // DEBUG: console.log ("deltaY: " + deltaY);
            var angleInDegrees = Math.atan2 (deltaY, deltaX); // * 180 / PI;
            // DEBUG: console.log ("angleInDegrees: " + angleInDegrees);

            // var nearestX = processing.screenWidth / 2 + (400 / 2) * Math.cos (angleInDegrees);
            // var nearestY = processing.screenHeight / 2 + (400 / 2) * Math.sin (angleInDegrees);
            var nearestX = 0 + (400 / 2) * Math.cos (angleInDegrees);
            var nearestY = 0 + (400 / 2) * Math.sin (angleInDegrees);

            var nearestPosition = {
                x: nearestX,
                y: nearestY
            };
            return nearestPosition;
        }

        /**
         * Get the distance to the loop from the given node.
         */
        looper.getDistanceFromEventLoop = function (behavior) {
            var distance = looper.lineDistance (behavior.x, behavior.y, behavior.xTarget, behavior.yTarget);
            // DEBUG: console.log ("Distance from loop: " + distance)
            return distance;
        }

        /**
         * Returns the distance between the two specified points.
         */
        looper.lineDistance = function (x1, y1, x2, y2) {
            // console.log("lineDistance");

            var xs = 0;
            var ys = 0;

            xs = x2 - x1;
            xs = xs * xs;

            ys = y2 - y1;
            ys = ys * ys;

            return Math.sqrt (xs + ys);
        }

        /**
         * Get the (x,y) point on the loop.
         */
        looper.getPointOnCircle = function (radius, originX, originY, angle) {

            x = originX + radius * Math.cos (angle);
            y = originY + radius * Math.sin (angle);

            var result = { x: x, y: y };

            return result;
        }

        /**
         * Setup behavior palette.
         */
        P.setupBehaviorPalette = function() {

            // TODO: Move "addBehavior" to looperInstance
            // TODO: Refactor setupBehaviorPalette to be part of Behavior class constructor, adding behaviors from the looperInstance (from previous TODO)

            // Add "default" behaviors to palette
            P.behaviorPalette.addBehavior ({
                type: 'light',
                label: 'on',

                x: P.behaviorPalette.x + -110,
                y: P.behaviorPalette.y + 0,

                procedure: function(options) {
                    console.log('light on top level');
                    // setPin(options);
                    // createBehavior ({ type: 'output' });
                    // createBehavior (options);
                    sendMessage (options);
                    // TODO: Keep track of state... has this been sent yet?
                },
                options: {
                    // type: 'output'
                    content: "turn output on"
                    // index: -1, type: 'output', pin: 5, operation: 1, type: 0, mode: 1, value: 1
                },
                properties: []
            });

            P.behaviorPalette.addBehavior ({
                type: 'module',
                label: 'sound',

                x: P.behaviorPalette.x + 110,
                y: P.behaviorPalette.y + 0,

                procedure: function(options) {
                    console.log('time on top level');
                    // delay(options);
                    // createBehavior (options);
                    sendMessage (options);
                    // TODO: Keep track of state... has this been sent yet?
                },
                options: {
                    // type: 'delay', milliseconds: 1000
                    content: "play note 500 800"
                    // index: -1, type: 'delay', milliseconds: 1000
                },
                properties: [
                    {
                        name: 'note',
                        minimum: 31,
                        maximum: 4978,
                        callback: function () { 
                            // console.log("NOTE");
                            // console.log (this);
                            // console.log (this.interface.value + " (scaled)");
                            var note = this.interface.structure.parent.sliders['note'].value; // this.interface.<slider>.<behavior node>
                            var duration = this.interface.structure.parent.sliders['duration'].value; // this.interface.<slider>.<behavior node>
                            sendMessage ({ content: "play note " + parseInt (note) + " " + parseInt (duration) });
                            // updateBehavior ({ type: 'sound', uuid: 691, note: parseInt (this.interface.value), duration: 1000 });
                            // sendMessage ({ content: "play sound 500 800" });
                        }
                    },
                    {
                        name: 'duration',
                        minimum: 0,
                        maximum: 1000,
                        callback: function () {
                            var note = this.interface.structure.parent.sliders['note'].value; // this.interface.<slider>.<behavior node>
                            var duration = this.interface.structure.parent.sliders['duration'].value; // this.interface.<slider>.<behavior node>
                            sendMessage ({ content: "play note " + parseInt (note) + " " + parseInt (duration) });
                            // updateBehavior ({ type: 'sound', uuid: 691, note: parseInt (this.interface.value), duration: 1000 });
                            // sendMessage ({ content: "play sound 500 800" });
                        }
                    }
                ]
            });

            P.behaviorPalette.addBehavior ({
                type: 'light',
                label: 'off',

                x: P.behaviorPalette.x + 0,
                y: P.behaviorPalette.y + 0,

                procedure: function (options) {
                    console.log('light off top level');
                    // setPin(options);
                    // createBehavior ({ type: 'output' });
                    // createBehavior (options);
                    sendMessage (options);
                    // TODO: Keep track of state... has this been sent yet?
                },
                options: {
                    // type: 'output',
                    // data: 'off'
                    content: "turn light off"
                    // index: -1, type: 'output', pin: 5, operation: 1, type: 0, mode: 1, value: 1
                },
                properties: []
            });

            P.behaviorPalette.addBehavior ({
                type: 'module',
                label: 'color',

                x: P.behaviorPalette.x + 0,
                y: P.behaviorPalette.y + 110,

                procedure: function(options) {
                    console.log('change color of module');
                    // createBehavior (options);
                    sendMessage (options);
                },
                options: {
                    content: "change color to blue"
                },
                properties: [
                    {
                        name: 'red',
                        minimum: 0,
                        maximum: 255,
                        callback: function () { 
                            console.log("NOTE");
                            console.log (this);
                            console.log (this.value + " (scaled)");
                            // alert (this.interface.value);
                            // alert (this.interface.structure.value); // this.interface.<slider>.<behavior node>
                            var red = this.interface.structure.parent.sliders['red'].value; // this.interface.<slider>.<behavior node>
                            var green = this.interface.structure.parent.sliders['green'].value; // this.interface.<slider>.<behavior node>
                            var blue = this.interface.structure.parent.sliders['blue'].value; // this.interface.<slider>.<behavior node>
                            // alert (this.interface.structure); // this.interface.<slider>.<behavior node>
                            // alert (this.interface.structure.parent); // this.interface.<slider>.<behavior node>
                            // // alert (this.interface.structure.parent.sliders); // this.interface.<slider>.<behavior node>
                            // alert (this.interface.structure.parent.properties); // this.interface.<slider>.<behavior node>
                            // // alert (this.interface.structure.parent.sliders.length); // this.interface.<slider>.<behavior node>
                            // alert (this.interface.structure.parent.properties.length); // this.interface.<slider>.<behavior node>
                            // alert (this.interface.value);
                            // updateBehavior ({ type: 'sound', uuid: 691, note: parseInt (this.interface.value), duration: 1000 });
                            // alert (this.values['red'] + ', ' + this.values['green'] + ', ' + this.values['blue']);
                            var red = this.interface.structure.parent.sliders['red'].value; // this.interface.<slider>.<behavior node>
                            var green = this.interface.structure.parent.sliders['green'].value; // this.interface.<slider>.<behavior node>
                            var blue = this.interface.structure.parent.sliders['blue'].value; // this.interface.<slider>.<behavior node>
                            sendMessage ({ content: "change color to " + red + "," + green + "," + blue });
                        }
                    },
                    {
                        name: 'green',
                        minimum: 0,
                        maximum: 255,
                        callback: function () { 
                            console.log("NOTE");
                            console.log (this);
                            console.log (this.value + " (scaled)");
                            // alert (this.interface.value);
                            // updateBehavior ({ type: 'sound', uuid: 691, note: parseInt (this.interface.value), duration: 1000 });
                            var red = this.interface.structure.parent.sliders['red'].value; // this.interface.<slider>.<behavior node>
                            var green = this.interface.structure.parent.sliders['green'].value; // this.interface.<slider>.<behavior node>
                            var blue = this.interface.structure.parent.sliders['blue'].value; // this.interface.<slider>.<behavior node>
                            sendMessage ({ content: "change color to " + red + "," + green + "," + blue });
                        }
                    },
                    {
                        name: 'blue',
                        minimum: 0,
                        maximum: 255,
                        callback: function () { 
                            console.log("NOTE");
                            console.log (this);
                            console.log (this.value + " (scaled)");
                            // alert (this.interface.value);
                            // updateBehavior ({ type: 'sound', uuid: 691, note: parseInt (this.interface.value), duration: 1000 });
                            var red = this.interface.structure.parent.sliders['red'].value; // this.interface.<slider>.<behavior node>
                            var green = this.interface.structure.parent.sliders['green'].value; // this.interface.<slider>.<behavior node>
                            var blue = this.interface.structure.parent.sliders['blue'].value; // this.interface.<slider>.<behavior node>
                            sendMessage ({ content: "change color to " + red + "," + green + "," + blue });
                        }
                    }
                ]
            });

            P.behaviorPalette.addBehavior ({
                type: 'module',
                label: 'message',

                x: P.behaviorPalette.x + 0,
                y: P.behaviorPalette.y - 110,

                procedure: function (options) {
                    console.log('send message to another module');
                    // createBehavior (options);
                    sendMessage (options);
                },
                options: {
                    content: "to all play sound 500 500"
                },
                properties: []
            });
        }

        /**
         * Get the angle.
         */
        P.getAngleFixed = function (x, y) {
            var deltaX = x; // - (processing.screenWidth / 2);
            var deltaY = y; // - (processing.screenHeight / 2);
            var angleInRadians = Math.atan2 (deltaY, deltaX); // * 180 / PI;
            angleInRadians = angleInRadians + (Math.PI / 2);
            // if (angleInRadians < 0) {
            //     angleInRadians = Math.PI + (Math.PI + angleInRadians);
            // }
            // angleInRadians = angleInRadians + (Math.PI / 2); // Offset by (PI / 2) radians
            // if (angleInRadians > (2 * Math.PI)) {
            //     angleInRadians = angleInRadians - (2 * Math.PI);
            // }
            if (angleInRadians < 0) {
                angleInRadians = Math.PI + (Math.PI + angleInRadians);
            }
            return angleInRadians;
        }

        P.getPosition = function (angle, radius) {

            radius = typeof radius !== 'undefined' ? radius : 400;

            var nearestX = (radius / 2) * Math.cos (angle);
            var nearestY = (radius / 2) * Math.sin (angle);

            var nearestPosition = {
                x: nearestX,
                y: nearestY
            };
            return nearestPosition;
        }

        //
        // Perspective
        //

        /**
         * Pans the perspective to the specified (x,y) position on the canvas.
         */
        P.panTo = function (x, y) {

            // Store previous offset
            looper.xOffset = -x;
            looper.yOffset = y;
        }

        /**
         * Pans the perspective by the specified increments along the x and y axes.
         */
        P.panBy = function (x, y) {

            // Store previous offset
            looper.xOffset = looper.xOffset - x;
            looper.yOffset = looper.yOffset + y;
        }

        P.scaleTo = function (factor) {

            looper.zoomFactor = factor;
        }

        P.panScale = function (x, y, factor) {

            console.log ('PANSCALE');

            // Store previous offset
            looper.xOffset = -x;
            looper.yOffset = y;

            looper.zoomFactor = factor;
        }
    }

    void draw () {

        // Update the position that was last touched in the user is touching
        // if (looper.hasCurrentDevice () === true) {
        //     if (looper.touch.touching === true) {
        //         var mouseX = looper.getCurrentDevice ().processing.screenWidth * (looper.getCurrentDevice ().processing.deviceCount + 1) + looper.getCurrentDevice ().processing.mouseX;
        //         var mouseY = looper.getCurrentDevice ().processing.mouseY;
        //         looper.touch.current = { x: mouseX, y: mouseY };
        //     }
        // }

        looper.processGesture ({ x: mouseX, y: mouseY });

        // Everything must be drawn relative to center
        pushMatrix ();
        translate (looper.xOffsetOrigin, looper.yOffsetOrigin);
        scale (looper.zoomFactor); // Use scale for 2D "zoom"
        translate (looper.xOffset / looper.zoomFactor, looper.yOffset / looper.zoomFactor); // The offset (note how we scale according to the zoom)


        background (#ffffff);
        primaryFont = createFont ("Comfortaa-Regular.ttf", 32);
        textFont (primaryFont, 40);
        textAlign (CENTER);
        fill (65, 65, 65);
        text ("pixeI", 0, 0 + 10);

        //
        // Draw loop
        //

        pushMatrix ();
        strokeWeight (looper.loop.style.strokeWeight);
        stroke (looper.loop.style.strokeColor.red, looper.loop.style.strokeColor.green, looper.loop.style.strokeColor.blue);
        noFill ();
        var loopScale = (looper.loop.behaviors.length > 0 || looper.loop.entangled === true) ? 1.0 : looper.geometry.loop.emptyScaleFactor;
        arc (0, 0, loopScale * (looper.geometry.loop.radius * 2), loopScale * (looper.geometry.loop.radius * 2), (-Math.PI / 2) + looper.geometry.loop.startAngle + looper.geometry.loop.startAngleOffset, (-this.PI / 2) + looper.geometry.loop.endAngle - looper.geometry.loop.endAngleOffset);
        popMatrix ();

        //
        // Draw the loop's arrowhead to indicate its sequence order
        //

        pushMatrix ();
        stroke (looper.loop.style.strokeColor.red, looper.loop.style.strokeColor.green, looper.loop.style.strokeColor.blue);
        rotate (-1 * looper.geometry.loop.endAngleOffset);
        translate (0, loopScale * -1 * looper.geometry.loop.radius);
        line (0, 0, -1 * looper.geometry.loop.arrowSegmentLength, looper.geometry.loop.arrowSegmentLength);
        line (0, 0, -1 * looper.geometry.loop.arrowSegmentLength, -1 * looper.geometry.loop.arrowSegmentLength);
        popMatrix ();

        //
        // Draw the behaviors
        //

        if (looper.hasCurrentDevice () === true) {
            looper.looperInstance.draw ();
        }

        popMatrix ();
    }

    void keyPressed () {
        // console.log ("keyPressed " + processing.key);

        if (key == 101) { // e
            console.log ("zoom in");
            looper.zoomFactor += 0.1;
        } else if (key == 113) { // q
            console.log ("zoom out");
            looper.zoomFactor -= 0.1;
        } else if (key == 119) { // w
            console.log ("pan up");

            // mouse = new PVector(mouseX, mouseY);
            // poffset.set(offset);
            looper.mouse_x = looper.mouseX;
            looper.mouse_y = looper.mouseY;
            looper.xOffsetPrevious = looper.xOffset;
            looper.yOffsetPrevious = looper.yOffset;

            // offset.x = mouseX - mouse.x + poffset.x;
            // offset.y = mouseY - mouse.y + poffset.y;
            looper.yOffset = 10 + looper.yOffsetPrevious;

            // DEBUG: console.log (processing.yOffset);

        } else if (key == 97) { // a
            console.log ("pan left");

            // mouse = new PVector(mouseX, mouseY);
            // poffset.set(offset);
            looper.mouse_x = looper.mouseX;
            looper.mouse_y = looper.mouseY;
            looper.xOffsetPrevious = looper.xOffset;
            looper.yOffsetPrevious = looper.yOffset;

            // offset.x = mouseX - mouse.x + poffset.x;
            // offset.y = mouseY - mouse.y + poffset.y;
            looper.xOffset = 10 + looper.xOffsetPrevious;
        } else if (key == 115) { // s
            console.log ("pan down");

            // mouse = new PVector(mouseX, mouseY);
            // poffset.set(offset);
            looper.mouse_x = looper.mouseX;
            looper.mouse_y = looper.mouseY;
            looper.xOffsetPrevious = looper.xOffset;
            looper.yOffsetPrevious = looper.yOffset;

            // offset.x = mouseX - mouse.x + poffset.x;
            // offset.y = mouseY - mouse.y + poffset.y;
            looper.yOffset = -10 + looper.yOffsetPrevious;
        } else if (key == 100) { // d
            console.log ("pan right");

            // mouse = new PVector(mouseX, mouseY);
            // poffset.set(offset);
            looper.mouse_x = looper.mouseX;
            looper.mouse_y = looper.mouseY;
            looper.xOffsetPrevious = looper.xOffset;
            looper.yOffsetPrevious = looper.yOffset;

            // offset.x = mouseX - mouse.x + poffset.x;
            // offset.y = mouseY - mouse.y + poffset.y;
            looper.xOffset = -10 + looper.xOffsetPrevious;
        }
    }
    </script>

    <script src="js/pixel.js"></script>
    <script src="js/looper.js"></script>
    <script>
    looper = new Looper ();
    // looper.addDevice({ address: "192.168.1.13" });
    // looper.addDevice({ address: "192.168.1.14" });
    // looper.showDeviceByIndex(-1);
    // erase();


    // create interface: behavior interface
    // create interface: slider: dot and line
    // create interface

    // function attachSlider (options) {
    function Slider (options) {

        var defaults = {
            parent: null,
            xOrigin: 0,
            yOrigin: 0,
            xTarget: 100,
            yTarget: 0,
            x: 0,
            y: 0,
            properties: [], // The properties of the interface that determine the ways of interacting with it
        };
        var options = options || {};
        var options = $.extend({}, defaults, options);

        options.structure = this; // Set the structure to this slider

        // Validate and copy the options to this class, to be used for creating an interface
        this.parent = options.parent; // i.e., the Behavior


        //looper.getCurrentDevice().attachInterface({
        var newInterface = this.parent.interface.attachInterface ({

            structure: null, // looper.getCurrentDevice(),

            properties: options.properties,

            // TODO: HACK! Fix this so the Processing instance is found automatically through the interface hierarchy!
            processing: looper.getCurrentDevice().processing, // this.looperInstance.processing,

            // The position of an interface is relative to its parent (if any), otherwise, relative to the window (or screen).
            xOrigin: options.xOrigin, // The origin of the interface's coordinate system along the x axis. This is relative to the parent's position along the x axis.
            yOrigin: options.yOrigin, // The origin of the interface's coordinate system along the y axis. This is relative to the parent's position along the y axis.
            xTarget: options.xTarget, // i.e., The desired or final position of the interface along the x axis. This is where the interface will eventually be (e.g., after it is animated into position).
            yTarget: options.yTarget, // i.e., The desired or final position of the interface along the y axis. This is where the interface will eventually be (e.g., after it is animated into position).
            x: options.x, // options.x, // was ev.gesture.center.x, // i.e., The current actual position of the interface along the x axis. This is updated in the drawing loop and will ultimately be equal to the target x position.
            y: options.y, // options.y, // was ev.gesture.center.y, // i.e., The current actual position of the interface along the y axis. This is updated in the drawing loop and will ultimately be equal to the target y position.

            // minX: 100,
            // maxX: 300,

            // This function determines whether the specified (x,y) point falls within the bounds of this interface.
            touches: function (x, y) {
                // alert (x, y, this.x, this.y);
                var radius = 50;
                // DEBUG: console.log (x, y, this.x, this.y);
                if (((this.xOrigin + this.x) - radius < x && (this.xOrigin + this.x) + radius > x) && ((this.yOrigin + this.y) - radius < y && (this.yOrigin + this.y) + radius > y)) {
                // if ((x - radius < this.processing.behaviorPalette.x + this.x && this.processing.behaviorPalette.x + this.x < x + radius)
                //     && (y - radius < this.processing.behaviorPalette.y + this.y && this.processing.behaviorPalette.y + this.y < y + radius)) {

                    return true;
                }

                return false;
            },

            // Updates the state of the interface before drawing
            update: function () {

            // Set constants
                this.min = 100;
                this.max = 300;

                // if (looper.touch.touching === true) {
                if (this.down) { // If touched

                    // Hide the cursor while sliding
                    // $('html').css('cursor', 'none');

                    // console.log ("DOWN");

                    // currentMouseX = (this.processing.screenWidth * (this.processing.deviceCount + 1) + this.processing.mouseX) - (this.processing.screenWidth / 2) - (this.xOrigin);
                    // console.log("currentMouseX: " + currentMouseX);
                    // console.log("screenMouseX: " + this.processing.screenMouseX);
                    // console.log("processing.zoomedCanvasMouseX: " + this.processing.zoomedCanvasMouseX);
                    currentMouseX = looper.zoomedCanvasMouseX - (this.xOrigin);
                    // currentMouseX = (this.processing.screenWidth * (this.processing.deviceCount + 1) + this.processing.mouseX) - (this.processing.screenWidth / 2) - (this.xOrigin);
                    // DEBUG: console.log (currentMouseX);
                    if (currentMouseX < this.min) {
                        currentMouseX = this.min;
                    } else if (currentMouseX > this.max) {
                        currentMouseX = this.max;
                    }

                    // console.log (currentMouseX);

                    // this.setPosition (currentMouseX, this.y);
                    // this.setPosition (currentMouseX, this.yOrigin + this.y);
                    this.setPosition (currentMouseX, this.y);
                } else {

                    // Show the mouse cursor
                    // $('html').css('cursor', 'auto');

                    // Hide the cursor while sliding
                    // $('html').css('cursor', 'auto');
                }

                this.updatePosition ();

            },

            draw: function () {

                this.update ();

                this.processing.pushMatrix();

                // Draw background of widget
                this.processing.line (this.xOrigin + this.min, this.yOrigin + this.y, this.xOrigin + this.max, this.yOrigin + this.y);

                // Draw the behavior
                this.processing.fill (66, 214, 146);
                // this.processing.ellipse (this.xOrigin + this.x, this.yOrigin + this.y, 30, 30);
                this.processing.ellipse (this.xOrigin + this.x, this.yOrigin + this.y, 30, 30);

                this.processing.popMatrix();


                // TODO: Invoke "callback" or "signal" for current state
                var range = this.max - this.min;
                var current = this.x - this.min;

                var value = current / range;
                // console.log (value + "%");

                var scaledMinimum = this.properties.minimum;
                var scaledMaximum = this.properties.maximum; // 1024;
                var scaledValue = value * (scaledMaximum - scaledMinimum) + scaledMinimum;
                this.value = scaledValue;
                this.structure.value = scaledValue;
                // alert (this.structure.value); // this.interface.<slider>.<behavior node>
                // alert (this.behavior.properties.length);
                // this.parent.values[this.name] = this.value;
                // console.log (scaledValue + " (scaled)");

                // TODO: Send musical note to Pixel via Looper

            },

            events: {
                tap: function() {
                    console.log ("tap Behavior");
                },

                touch: function() {
                    console.log ("touch Behavior");
                    console.log (this);
                    console.log (this.interface);

                    disableEventCreate = true;

                    this.interface.down = true;

                    // Hide the mouse cursor
                    // $('html').css('cursor', 'none');
                },

                hold: function () {
                    console.log("hold Behavior");
                },

                release: function () {
                    console.log("release Behavior");

                    this.interface.down = false;

                    disableEventCreate = false;

                    this.interface.properties.interface = this.interface;
                    this.interface.properties.callback ();

                    // Show the mouse cursor
                    // $('html').css('cursor', 'auto');
                }
            }
        });

        newInterface.properties = options.properties;

        newInterface.structure = this;

        return newInterface;

    }

    </script>

    <!-- 
    <div id="fullpage">
        <strong>HTTP Server</strong>

        <p>
            <button onclick="startServer('htdocs');">Start Httpd at www/htdocs</button>
            <button onclick="startServer('/');">Start Httpd at /</button>
            <button onclick="stopServer();">Stop Httpd</button>
            <button onclick="updateStatus();">Check Status</button>
            <button onclick="getModules();">Get Modules</button></p>
            <button onclick="getModulesHTTP();">Get Modules (HTTP)</button>
            <button onclick="hello();">Hello</button>
            <button onclick="goodbye();">Goodbye</button>
        </p>

        <div id='location'></div>
        <div id='url'></div>
        <div id='localpath'></div>

        <h2><div id="looper">Looper</div></h2>

        <strong>UDP Client</strong>

        <p><button onclick="udpBroadcast();">UDP Broadcast</button></p>

        <strong>Accelerometer</strong>

        <p><button onclick="getAccelerometerData();">Accelerometer</button></p>

        <div id="acceleration"></div>
    </div> 
    -->
    
    </body>
</html>
